---
title: "My Way of Doing Go Middleware" # Title of the blog post.
date: 2021-05-10T14:48:07+01:00 # Date of post creation.
description: "Article description." # Description used for search engine.
featured: true # Sets if post is a featured post, making it appear on the sidebar. A featured post won't be listed on the sidebar if it's the current page
draft: false # Sets whether to render this page. Draft of true will not be rendered.
toc: false # Controls if a table of contents should be generated for first-level links automatically.
# menu: main
# featureImage: "/images/path/file.jpg" # Sets featured image on blog post.
codeLineNumbers: false # Override global value for showing of line numbers within code block.
figurePositionShow: true # Override global value for showing the figure label.
categories:
  - Technology
  - Development
tags:
  - Go
---

I recently had a task to work on some refactoring of scary code, and so used this as an excuse to try out some different ways of serving up an api. Over the years, I have taken inspiration from various ideas. I've particularly appreciated Mat Ryer's post on [How I write Go HTTP services after seven years](https://medium.com/@matryer/how-i-write-go-http-services-after-seven-years-37c208122831). If you haven't read it, go take a look. 

I've often used Mat's post as a starting point for when I create new APIs, and it's quick to get something up and running, that will be ready for making more complicated when the time comes. 

The code I was looking at had an enormous number of routes (like 80), and had initially been autogenerated from Swagger. Different people probably have different views on the usefulness of generated code. I think it has it's place, but things don't feel right when `main.go` is generated.

One of the things I tried for this project was to use middleware functions (as Mat suggests) to separate out particular cross-cutting concerns (logging, auth, ensuring headers), and then use a response wrapper for the handler that does the actual work. 

Let's get some code going then. This is my idea for a response wrapper:

``` go
func mwResponseWrapper(handler func(*http.Request) (OkResponse, error)) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		okResp, err := handler(r)
		if err != nil {
			handleError(w, r, err)
			return
		}

		// Ok Response...
		w.WriteHeader(okResp.SuccessStatusCode())
		_, ok := okResp.(response.GenericResponse)
		if !ok {
			w.Header().Add("Content-Type", "application/json")
			if err := json.NewEncoder(w).Encode(okResp); err != nil {
				w.Write([]byte(err.Error()))
				return
			}
		}
	}
}
```

The wrapper is really just a way of handling errors and happy path responses so that we don't have the same repeating code doing json serialisation and deciding what http codes to return.

I created an `OkResponse` interface so that the actual handler returns something that the response wrapper can deal with. It's not very complicated:

``` go 
type OkResponse interface {
	SuccessStatusCode() int
}
```

We then have something for handling errors. This might be simplified in the future. I haven't totally decided on how this should work:

``` go
func handleError(w http.ResponseWriter, r *http.Request, err error) {
	lg := log.WithContext(r.Context())
	appError, ok := err.(appErrors.Error)
	if !ok { // this error shouldn't have happened
		w.WriteHeader(http.StatusInternalServerError)
		lg.WithError(err).Error("an error that shouldn't have happened")
		return
	}

	w.WriteHeader(appError.StatusCode())

	//errMsg := err.Error()
	if nestedErr := errors.Unwrap(appError); nestedErr != nil {
		lg = lg.WithError(nestedErr)
		//errMsg = fmt.Sprintf("%s\nDetails: %s\n", errMsg, nestedErr.Error())
	}
	if notfound, ok := err.(appErrors.NotFound); ok {
		lg = lg.WithField(notfound.EntityType, notfound.Term)
	}
	_, ok = err.(appErrors.InternalServerError)
	if ok {
		lg.Error(err.Error())
	} else {
		lg.Warn(err.Error())
	}
	errorWithInfo, ok := err.(appErrors.ErrorWithInfo)
	if ok {
		w.Header().Add("Content-Type", "application/json")
		if err := json.NewEncoder(w).Encode(errorWithInfo.Info()); err != nil {
			w.Write([]byte(err.Error()))
		}
	}
}
```

Ideally there shouldn't be much logic in here, as the errors themselves might describe what to do, it's just that I want certain errors to have certain logging information. So the `NotFound` error type has information on the entity that couldn't be found, for example.

I've wrapped up errors so that there can be a bit more information with how to deal with them similar to the happy path response. Again, this is not particularly complicated:

``` go
type Error interface {
	error
	StatusCode() int
}
```

What this really means is I can focus on what the handler is doing, instead of faffing with checking the same stuff every time. So here is a typical handler which gets called by the response wrapper:

``` go
func (s *server) handlePostTaskReassign() func(*http.Request) (OkResponse, error) {
	return func(r *http.Request) (OkResponse, error) {
		sessionDetails, ok := SessionDetails(r.Context())
		if !ok {
			return nil, errors.New("couldn't get session details")
		}

		taskID, err := extractTaskID(r)
		if err != nil {
			return nil, err
		}

		req := &jsonrequest.TaskIDReassign{}

		if err := deserialiseAndValidate(req, r.Body); err != nil {
			return nil, err
		}

		req.TaskID = taskID

		return s.core.ReassignTask(r.Context(), *req, sessionDetails)
	}
}
```